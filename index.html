<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro Resonance | 量子周波数調律システム</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        body {
            background: radial-gradient(circle at 50% 0%, #1e293b 0%, #0f172a 40%, #020617 100%);
            font-family: 'Noto Sans JP', sans-serif;
            color: #e2e8f0;
        }
        .font-cinzel { font-family: 'Cinzel', serif; }
        
        @keyframes floatUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .anim-entry { animation: floatUp 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards; opacity: 0; }
        .delay-100 { animation-delay: 0.1s; }
        .delay-200 { animation-delay: 0.2s; }
        .delay-300 { animation-delay: 0.3s; }

        .scope-screen {
            background: #000;
            background-image: 
                linear-gradient(rgba(16, 185, 129, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(16, 185, 129, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.9);
            border: 1px solid #334155;
            position: relative;
            overflow: hidden;
        }
        
        .glass-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        /* 最終波形表示用のスタイル */
        .final-wave-container {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #14b8a6;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(20, 184, 166, 0.1);
        }

        /* フローティング録音ウィンドウ */
        #recording-float {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(20px);
            border: 2px solid #ec4899;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(236, 72, 153, 0.3);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #recording-float.active {
            opacity: 1;
            pointer-events: auto;
        }
        .rec-pulse {
            animation: recPulse 1s ease-in-out infinite;
        }
        @keyframes recPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
    </style>
</head>
<body class="min-h-screen selection:bg-teal-500/30">

    <div class="min-h-screen flex flex-col">
        
        <header class="w-full border-b border-slate-800/60 bg-slate-950/40 backdrop-blur-md sticky top-0 z-50">
            <div class="mx-auto max-w-6xl px-4 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="h-10 w-10 rounded-full border border-teal-500/50 flex items-center justify-center bg-teal-500/10 text-teal-400 font-cinzel font-bold">
                        AR
                    </div>
                    <div class="flex flex-col leading-tight">
                        <span class="font-bold tracking-[0.15em] text-xs uppercase text-teal-500">
                            Astro Resonance
                        </span>
                        <span class="font-cinzel text-lg text-slate-100 tracking-wide">
                            Quantum Tuning System
                        </span>
                    </div>
                </div>
                <div class="hidden md:flex items-center gap-4 text-xs font-mono text-slate-500">
                    <span>SYS: ONLINE</span>
                    <span>VER: 3.2.0</span>
                </div>
            </div>
        </header>

        <main class="flex-1 w-full mx-auto max-w-5xl px-4 pt-10 pb-24">

            <div class="text-center mb-16 anim-entry">
                <p class="text-xs font-bold tracking-[0.4em] uppercase text-slate-500 mb-4">
                    Scientific Frequency Alignment
                </p>
                <h1 class="text-3xl md:text-5xl font-bold font-cinzel text-transparent bg-clip-text bg-gradient-to-r from-teal-200 via-slate-100 to-teal-200 mb-6 drop-shadow-lg">
                    運命と音声の<span class="text-teal-400">科学的統合</span>
                </h1>
                <p class="text-sm md:text-base text-slate-400 leading-loose max-w-3xl mx-auto">
                    本システムは、<span class="text-slate-200 font-semibold">「時間（算命学）」「空間（カタカムナ）」「現象（フーリエ解析）」</span>の3つの座標軸を統合する世界初のアルゴリズムです。<br>
                    あなたの生体エネルギー（声）を数学的に分解し、運命式から導かれる理想波形とのズレを補正する「共鳴音」を生成します。
                </p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-16 anim-entry delay-100">
                <div class="glass-panel p-6 rounded-2xl border-t-2 border-t-blue-500/50 hover:bg-slate-800/50 transition-colors">
                    <div class="text-xs font-mono text-blue-400 mb-2">TEMPORAL COORDINATE</div>
                    <h3 class="text-lg font-bold text-slate-100 mb-3">算命学 (Time)</h3>
                    <p class="text-xs text-slate-400 leading-relaxed text-justify">
                        生年月日は単なる記号ではなく、太陽と地球の位置関係が示す「磁場」の記録です。あなたが生まれた瞬間の宇宙のエネルギー配置を座標化し、魂が本来持つべき「基本振動数（Fundamental Frequency）」を算出します。これが調整の目標値となります。
                    </p>
                </div>
                <div class="glass-panel p-6 rounded-2xl border-t-2 border-t-emerald-500/50 hover:bg-slate-800/50 transition-colors">
                    <div class="text-xs font-mono text-emerald-400 mb-2">SPATIAL VIBRATION</div>
                    <h3 class="text-lg font-bold text-slate-100 mb-3">カタカムナ (Space)</h3>
                    <p class="text-xs text-slate-400 leading-relaxed text-justify">
                        「名は体を表す」という言葉通り、氏名の音韻は空間に物理的な振動を与えます。カタカムナ物理学に基づき、あなたの名前の響きを物理的な周波数に変換。後天的に与えられた「音の資質」を解析し、宿命との整合性を検証します。
                    </p>
                </div>
                <div class="glass-panel p-6 rounded-2xl border-t-2 border-t-purple-500/50 hover:bg-slate-800/50 transition-colors">
                    <div class="text-xs font-mono text-purple-400 mb-2">SIGNAL PROCESSING</div>
                    <h3 class="text-lg font-bold text-slate-100 mb-3">フーリエ変換 (Signal)</h3>
                    <p class="text-xs text-slate-400 leading-relaxed text-justify">
                        高速フーリエ変換（FFT）アルゴリズムを用いて、入力されたあなたの「生声」を周波数スペクトルに分解します。複雑な波形の中から優勢な周波数を特定し、算命学（理想）とカタカムナ（資質）との「誤差」を数学的に計算します。
                    </p>
                </div>
            </div>

            <div id="step1" class="glass-panel rounded-3xl p-8 mb-10 anim-entry delay-200 transition-all duration-500">
                <div class="flex items-center gap-4 mb-8">
                    <div class="h-8 w-8 rounded bg-slate-800 text-slate-400 flex items-center justify-center font-mono text-sm border border-slate-700">01</div>
                    <h2 class="text-xl font-bold text-slate-100">解析パラメーター入力</h2>
                </div>
                
                <div class="grid gap-8 md:grid-cols-2">
                    <div>
                        <label class="block text-xs font-bold tracking-wider text-slate-500 mb-3">NAME (HIRAGANA)</label>
                        <input type="text" id="inp-name" value="たなかたろう" placeholder="あかさ" 
                            class="w-full bg-slate-950/50 border border-slate-700 rounded-xl px-5 py-4 text-slate-200 focus:outline-none focus:border-teal-500/50 focus:ring-1 focus:ring-teal-500/50 transition-all font-lg">
                    </div>
                    <div>
                        <label class="block text-xs font-bold tracking-wider text-slate-500 mb-3">BIRTH DATE</label>
                        <input type="date" id="inp-date" value="1995-08-08" 
                            class="w-full bg-slate-950/50 border border-slate-700 rounded-xl px-5 py-4 text-slate-200 focus:outline-none focus:border-teal-500/50 focus:ring-1 focus:ring-teal-500/50 transition-all font-lg">
                    </div>
                </div>

                <div class="mt-8">
                    <button onclick="console.log('✅ Button clicked'); app.analyzeSequence()" id="btn-analyze"
                        class="w-full md:w-auto px-12 py-4 rounded-full bg-slate-100 text-slate-900 font-bold text-sm tracking-widest hover:bg-teal-400 hover:shadow-[0_0_30px_rgba(45,212,191,0.3)] transition-all transform hover:-translate-y-1">
                        INITIALIZE ANALYSIS
                    </button>
                </div>
            </div>

            <!-- 新規追加: STEP 1.5 波形生成 -->
            <div id="step1-5" class="hidden glass-panel rounded-3xl p-8 mb-10 border-t-2 border-t-cyan-500/50">
                <div class="flex items-center gap-4 mb-8">
                    <div class="h-8 w-8 rounded bg-cyan-500/10 text-cyan-500 flex items-center justify-center font-mono text-sm border border-cyan-500/20">02</div>
                    <h2 class="text-xl font-bold text-cyan-100">あなた専用の波形を生成中...</h2>
                </div>

                <div class="text-center py-12">
                    <div class="inline-block mb-6">
                        <svg class="animate-spin h-16 w-16 text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>
                    <div id="gen-status" class="text-lg font-mono text-cyan-300 mb-4">CALCULATING RESONANCE FREQUENCY...</div>
                    <div class="text-xs text-slate-500">算命学とカタカムナの統合計算を実行中</div>
                </div>
            </div>

            <div id="step2" class="hidden glass-panel rounded-3xl p-8 mb-10 border-t-2 border-t-yellow-500/50">
                <div class="flex items-center gap-4 mb-8">
                    <div class="h-8 w-8 rounded bg-yellow-500/10 text-yellow-500 flex items-center justify-center font-mono text-sm border border-yellow-500/20">03</div>
                    <h2 class="text-xl font-bold text-yellow-100">守護周波数の特定</h2>
                </div>

                <div id="sanmei-result" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    </div>

                <div class="p-6 bg-slate-950/30 rounded-xl border border-slate-800/50 mb-8">
                    <h4 class="text-sm font-bold text-yellow-400 mb-2">▼ 生成ロジック解説</h4>
                    <p class="text-xs text-slate-400 leading-relaxed text-justify">
                        上記の結果に基づき、あなたのエネルギーフィールドの欠落部分を補完するサイン波（Sine Wave）と、カタカムナの数理に基づく倍音（Harmonics）を合成しました。
                        さらに、<span class="text-teal-400 font-semibold">地球の電磁場共鳴周波数である7.83Hz（シューマン共鳴）</span>を統合することで、あなたの意識と地球、そして宇宙との調律を促進します。
                        この音は、単なるリラクゼーション音ではなく、あなたの脳波を「宿命的な最適値」へと誘導するキャリア波（搬送波）として機能します。
                    </p>
                </div>

                <div class="scope-screen h-48 w-full rounded-xl mb-6 relative">
                    <canvas id="visualizer" class="w-full h-full block"></canvas>
                    <div class="absolute bottom-2 right-4 text-[10px] font-mono text-emerald-500">
                        GAIN: <span id="gain-val">-INF</span> dB
                    </div>
                </div>

                <div class="flex justify-center">
                    <button id="btn-play" onclick="app.playSound()" 
                        class="px-10 py-3 rounded-full border border-yellow-500/50 text-yellow-400 font-bold text-sm hover:bg-yellow-500 hover:text-slate-900 transition-all tracking-wider shadow-[0_0_20px_rgba(234,179,8,0.1)]">
                        ▶ AUDIO CHECK
                    </button>
                </div>
            </div>

            <div id="step3" class="hidden glass-panel rounded-3xl p-8 mb-10 border-t-2 border-t-fuchsia-500/50">
                <div class="flex items-center gap-4 mb-6">
                    <div class="h-8 w-8 rounded bg-fuchsia-500/10 text-fuchsia-500 flex items-center justify-center font-mono text-sm border border-fuchsia-500/20">04</div>
                    <h2 class="text-xl font-bold text-fuchsia-100">生体エネルギー統合 (Rec)</h2>
                </div>

                <div class="mb-8 text-sm text-slate-300 leading-relaxed">
                    再生される音に合わせ、<span class="text-fuchsia-300 font-bold">5秒間</span> 声を出してください。<br>
                    <span class="text-xs text-slate-400">
                    あなたの声をリアルタイムでFFT（高速フーリエ変換）により周波数スペクトルに分解し、
                    五行（木火土金水）の各周波数帯域のエネルギー分布を解析します。
                    守護周波数との同期率も算出されます。
                    </span>
                </div>

                <div class="mb-6 glass-panel p-4 rounded-xl border border-teal-500/30 bg-slate-900/50">
                    <label class="block text-xs font-bold tracking-wider text-teal-400 mb-2">🎵 GENERATED AUDIO DURATION</label>
                    <div class="flex items-center gap-4">
                        <input type="number" id="inp-duration" value="10" min="1" max="300" step="1"
                            class="w-24 bg-slate-950/80 border border-slate-700 rounded-lg px-4 py-2 text-slate-100 font-mono text-lg focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500 transition-all">
                        <span class="text-sm text-slate-400">生成する音声の長さ（1〜300秒）</span>
                    </div>
                </div>

                <div class="flex gap-4">
                    <button id="btn-rec" onclick="app.startMic()" 
                        class="flex-1 py-4 rounded-xl bg-slate-800 border border-fuchsia-500/30 text-fuchsia-300 font-bold hover:bg-fuchsia-500 hover:text-white transition-all">
                        ● START RECORDING
                    </button>
                    <button id="btn-stop" onclick="app.stopMic()" disabled
                        class="flex-1 py-4 rounded-xl bg-slate-900 text-slate-600 font-bold disabled:cursor-not-allowed enabled:bg-slate-100 enabled:text-slate-900 transition-all">
                        ■ MERGE DATA
                    </button>
                </div>
                <div id="rec-status" class="mt-4 text-xs text-slate-500 font-mono text-center h-4"></div>
            </div>

            <div id="step4" class="hidden glass-panel rounded-3xl p-8 mb-10 border-t-2 border-t-teal-500/50">
                <div class="text-center mb-8">
                    <div class="inline-block px-4 py-1 rounded-full bg-teal-500/10 text-teal-400 border border-teal-500/20 text-xs font-bold tracking-widest mb-4 animate-pulse">
                        SYNC COMPLETE
                    </div>
                    <h3 class="text-2xl font-cinzel text-slate-100 mb-2">多次元統合完了</h3>
                    <div id="voice-comment" class="text-sm text-slate-400"></div>
                </div>

                <div class="relative w-full max-w-lg mx-auto aspect-square mb-10 p-4 bg-slate-950/50 rounded-2xl border border-slate-800">
                    <canvas id="radarChart"></canvas>
                </div>

                <div class="mb-10">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="h-2 w-2 rounded-full bg-teal-500"></span>
                        <h4 class="text-xs font-bold text-teal-400 tracking-widest">GENERATED RESONANCE WAVEFORM <span id="duration-display">(10s)</span></h4>
                    </div>
                    <div class="final-wave-container h-24 w-full relative overflow-hidden">
                        <canvas id="finalWaveVisualizer" class="w-full h-full"></canvas>
                        <div class="absolute top-0 left-0 w-full h-full pointer-events-none" 
                             style="background-image: linear-gradient(90deg, rgba(20,184,166,0.1) 1px, transparent 1px); background-size: 10% 100%;">
                        </div>
                    </div>
                    <p class="text-[10px] text-slate-500 text-right mt-1 font-mono">
                        FORMAT: WAV / 44.1kHz / 32bit Float
                    </p>
                </div>

                <div class="flex flex-col items-center gap-4">
                    <p class="text-xs text-slate-500 max-w-md text-center mb-2 leading-relaxed">
                        算出された「3つの座標」を統合し、あなた専用の補正WAVファイルを生成しました。<br>
                        <span class="text-teal-400 font-semibold">あなたの意識と地球と宇宙の調律のための解放の周波数、7.83Hzも合成しました。</span><br>
                        この音源をアラームや瞑想に使用してください。
                    </p>
                    <button onclick="app.downloadWav()" 
                        class="w-full md:w-auto px-12 py-4 rounded-full bg-teal-500 text-slate-900 font-bold tracking-widest hover:bg-teal-400 hover:shadow-[0_0_40px_rgba(20,184,166,0.4)] transition-all transform hover:-translate-y-1">
                        ↓ DOWNLOAD RESONANCE (.wav)
                    </button>
                </div>

                <!-- アラーム音生成セクション -->
                <div id="alarm-section" class="mt-16 pt-12 border-t border-purple-500/30">
                    <div id="alarm-confirm" class="text-center mb-8">
                        <div class="inline-block px-4 py-2 rounded-full bg-purple-500/10 border border-purple-500/30 mb-4">
                            <span class="text-xl">🔔</span>
                        </div>
                        <h3 class="text-xl font-bold text-purple-100 mb-4">アラーム音生成</h3>
                        <p class="text-sm text-slate-300 mb-6 leading-relaxed max-w-md mx-auto">
                            生成されたオリジナル周波数オーディオファイルを元に<br>
                            <span class="text-purple-300 font-bold">穏やかな目覚めを促すアラーム音</span>を作れます。
                        </p>
                        <p class="text-lg text-white font-bold mb-6">作りますか？</p>
                        
                        <div class="flex justify-center gap-6">
                            <button onclick="app.generateAlarms()" 
                                class="px-16 py-4 rounded-full bg-purple-500 text-white font-bold text-lg tracking-widest hover:bg-purple-400 hover:shadow-[0_0_40px_rgba(168,85,247,0.4)] transition-all transform hover:-translate-y-1">
                                YES
                            </button>
                            <button onclick="document.getElementById('alarm-section').classList.add('hidden')" 
                                class="px-16 py-4 rounded-full bg-slate-700 text-slate-300 font-bold text-lg tracking-widest hover:bg-slate-600 transition-all">
                                NO
                            </button>
                        </div>
                    </div>

                    <!-- アラーム生成中表示 -->
                    <div id="alarm-generating" class="hidden text-center py-12">
                        <div class="inline-block mb-6">
                            <svg class="animate-spin h-16 w-16 text-purple-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        </div>
                        <div class="text-lg font-mono text-purple-300 mb-4">GENERATING ALARM SOUNDS...</div>
                        <div class="text-xs text-slate-500">2パターンのアラーム音を生成中</div>
                    </div>

                    <!-- アラーム完成表示 -->
                    <div id="alarm-ready" class="hidden">
                        <div class="text-center mb-8">
                            <div class="inline-block px-4 py-1 rounded-full bg-purple-500/10 text-purple-400 border border-purple-500/20 text-xs font-bold tracking-widest mb-4">
                                ALARM READY
                            </div>
                            <h3 class="text-xl font-bold text-purple-100 mb-4">2パターンのアラーム音が完成しました</h3>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- パターン1 -->
                            <div class="glass-panel p-6 rounded-xl border border-purple-500/30">
                                <div class="flex items-center gap-2 mb-4">
                                    <span class="text-2xl">😌</span>
                                    <h4 class="text-lg font-bold text-purple-200">Pattern 1</h4>
                                </div>
                                <h5 class="text-sm font-bold text-white mb-3">静かな呼吸に同調する目覚め</h5>
                                <p class="text-xs text-slate-400 leading-relaxed mb-4">
                                    無音に近いレベルから15〜25秒でゆっくりフェードイン。丸みのある倍音で、わずかに揺らぐ音量・音程変化。「起こす」のではなく「気づいたら目が覚めている」状態を目指します。
                                </p>
                                <button onclick="app.downloadAlarm(1)" 
                                    class="w-full py-3 rounded-lg bg-purple-500/20 border border-purple-500/50 text-purple-300 font-bold hover:bg-purple-500 hover:text-white transition-all">
                                    ↓ DOWNLOAD ALARM 1
                                </button>
                            </div>

                            <!-- パターン2 -->
                            <div class="glass-panel p-6 rounded-xl border border-purple-500/30">
                                <div class="flex items-center gap-2 mb-4">
                                    <span class="text-2xl">🌅</span>
                                    <h4 class="text-lg font-bold text-purple-200">Pattern 2</h4>
                                </div>
                                <h5 class="text-sm font-bold text-white mb-3">朝の光がカーテン越しに差し込む瞬間</h5>
                                <p class="text-xs text-slate-400 leading-relaxed mb-4">
                                    20秒以上かけて緩やかにフェードイン。中高域に優しい倍音が徐々に加わり、明るさは増すが刺激にはならないバランス。「空間が明るくなる感覚」を音で表現します。
                                </p>
                                <button onclick="app.downloadAlarm(2)" 
                                    class="w-full py-3 rounded-lg bg-purple-500/20 border border-purple-500/50 text-purple-300 font-bold hover:bg-purple-500 hover:text-white transition-all">
                                    ↓ DOWNLOAD ALARM 2
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </main>
        
        <footer class="border-t border-slate-800/80 bg-slate-950/60 py-8 text-center">
            <div class="text-[10px] font-mono text-slate-600">
                © 2025 COSMIC NEURAL NETWORK // ASTRO RESONANCE SYSTEM
            </div>
        </footer>

        <!-- フローティング録音ウィンドウ -->
        <div id="recording-float">
            <div class="text-center mb-6">
                <div class="inline-flex items-center gap-3 mb-4">
                    <div class="h-4 w-4 rounded-full bg-red-500 rec-pulse"></div>
                    <span class="text-xl font-bold text-fuchsia-300">RECORDING</span>
                </div>
                <div class="text-4xl font-mono font-bold text-white mb-2" id="rec-timer">5.0</div>
                <div class="text-xs text-slate-400">秒後に自動停止します</div>
            </div>
            
            <div class="scope-screen h-32 rounded-xl mb-4">
                <canvas id="floatingWaveform" class="w-full h-full"></canvas>
            </div>
            
            <div class="text-center text-xs text-slate-500">
                声を出し続けてください...
            </div>
        </div>
    </div>

    <script>
        // デバイス検出（モバイル対応用）
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        console.log('📱 Device:', { isMobile, isIOS });

        const Logic = {
            calcElements: function(dateStr) {
                const d = new Date(dateStr);
                const types = [
                    { n:"木性 (WOOD)", desc:"成長・神経系・直感", detail:"「木」は春のエネルギーを象徴し、上へ外へと伸びる性質を持ちます。人体では肝臓・神経系に対応。この周波数は、停滞した思考を打破し、新しい神経回路の形成を促す作用があるとされています。", freq: 396 }, 
                    { n:"火性 (FIRE)", desc:"情熱・循環器・変容", detail:"「火」は夏のエネルギーで、拡散と上昇を司ります。人体では心臓・循環器に対応。528HzはDNA修復周波数とも呼ばれ、細胞レベルでの活性化と、感情的なブロックの解放（変容）を物理的にサポートします。", freq: 528 }, 
                    { n:"土性 (EARTH)", desc:"安定・消化器・接続", detail:"「土」は季節の変わり目（土用）を司り、受容と統合の性質を持ちます。人体では胃・脾臓に対応。この周波数は、グラウンディング（地に足をつける）効果が高く、不安定な生体磁場を地球のシューマン共振へと同調させます。", freq: 639 }, 
                    { n:"金性 (METAL)", desc:"改革・呼吸器・収穫", detail:"「金」は秋の結実を表し、不必要なものを切り捨てる改革の性質を持ちます。人体では肺・呼吸器に対応。741Hzは「表現の周波数」とされ、喉のチャクラに作用し、デトックス効果と自己表現の純度を高める物理特性があります。", freq: 741 }, 
                    { n:"水性 (WATER)", desc:"知性・腎泌尿・柔軟", detail:"「水」は冬の凝縮エネルギーで、本質的な知恵と柔軟性を表します。人体では腎臓に対応。852Hzは松果体を活性化させると言われ、直感力を高めると同時に、体液（血液・リンパ）のミクロな振動を整える役割を果たします。", freq: 852 }  
                ];
                const val = d.getFullYear() + d.getMonth() + d.getDate();
                const myIdx = val % 5;
                const guardIdx = (myIdx + 2) % 5; 
                return { my: types[myIdx], guard: types[guardIdx] };
            },
            calcNameValue: function(name) {
                let score = 0;
                for(let i=0; i<name.length; i++) score += name.charCodeAt(i);
                const seed = score;
                return [
                    (seed % 100) * 0.8 + 20,
                    ((seed * 2) % 100) * 0.8 + 20,
                    ((seed * 3) % 100) * 0.8 + 20,
                    ((seed * 4) % 100) * 0.8 + 20,
                    ((seed * 5) % 100) * 0.8 + 20
                ];
            }
        };

        window.app = {
            ctx: null, analyzer: null, micSrc: null, micStream: null,
            isPlaying: false, animId: null, floatingAnimId: null, elements: null,
            chart: null, isProcessing: false,
            recordedData: [50, 50, 50, 50, 50],
            nameData: [0,0,0,0,0],
            finalAudioBuffer: null, // 生成された音声データを保持
            audioSamples: [], // FFT分析用の音声サンプル
            recordingStartTime: null,
            alarmPattern1: null, // アラームパターン1
            alarmPattern2: null, // アラームパターン2
            
            init: function() {
                console.log('🟡 App initialized');
                const p = new URLSearchParams(window.location.search);
                const dob = p.get('dob');
                const name = p.get('name');
                if(dob) {
                    const fmt = dob.substring(0,4)+'-'+dob.substring(4,6)+'-'+dob.substring(6,8);
                    document.getElementById('inp-date').value = fmt;
                    if(name) document.getElementById('inp-name').value = decodeURIComponent(name);
                    setTimeout(() => {
                        document.getElementById('step1').scrollIntoView({ behavior: 'smooth', block: 'center' });
                        const btn = document.getElementById('btn-analyze');
                        btn.classList.add('ring-2', 'ring-teal-400', 'ring-offset-2', 'ring-offset-slate-900');
                        setTimeout(() => btn.classList.remove('ring-2', 'ring-teal-400', 'ring-offset-2', 'ring-offset-slate-900'), 1500);
                    }, 600);
                }
                console.log('🟡 App ready, button should be clickable');
            },

            analyzeSequence: function() {
                try {
                    console.log('🔵 analyzeSequence started');
                    const btn = document.getElementById('btn-analyze');
                    if (!btn) {
                        console.error('❌ Button not found');
                        return;
                    }
                    const originalText = btn.innerText;
                    btn.disabled = true;
                    btn.classList.add('opacity-75', 'cursor-wait');
                    console.log('🔵 Button disabled, showing step1-5');
                    
                    // STEP 1.5を先に表示
                    setTimeout(() => {
                        try {
                            this.showStep('step1-5');
                            console.log('🔵 step1-5 shown');
                            
                            const statusMsgs = [
                                "ACCESSING UNIVERSAL GRID...",
                                "CALCULATING WAVEFORMS...",
                                "SYNCHRONIZING DIMENSIONS...",
                                "GENERATING RESONANCE PATTERN..."
                            ];
                            let i = 0;
                            const interval = setInterval(() => { 
                                const statusEl = document.getElementById('gen-status');
                                if (statusEl) {
                                    statusEl.innerText = statusMsgs[i % statusMsgs.length];
                                }
                                i++; 
                            }, 700);
                            
                            setTimeout(() => {
                                try {
                                    clearInterval(interval);
                                    console.log('🔵 Calling analyze()');
                                    this.analyze();
                                    btn.innerText = originalText;
                                    btn.disabled = false;
                                    btn.classList.remove('opacity-75', 'cursor-wait');
                                    console.log('🔵 Showing step2');
                                    // STEP 2を表示
                                    this.showStep('step2');
                                } catch (error) {
                                    console.error('❌ Error in inner timeout:', error);
                                }
                            }, 3000);
                        } catch (error) {
                            console.error('❌ Error in outer timeout:', error);
                        }
                    }, 100);
                } catch (error) {
                    console.error('❌ Error in analyzeSequence:', error);
                }
            },

            analyze: function() {
                console.log('🟢 analyze() called');
                const date = document.getElementById('inp-date').value;
                const name = document.getElementById('inp-name').value;
                console.log('🟢 Date:', date, 'Name:', name);
                if(!date) {
                    alert("DATE REQUIRED");
                    return;
                }
                
                this.elements = Logic.calcElements(date);
                this.nameData = Logic.calcNameValue(name || "dummy");
                console.log('🟢 Elements calculated:', this.elements);

                const html = `
                    <div class="glass-panel p-4 rounded-xl border-l-2 border-l-slate-500">
                        <div class="text-[10px] font-mono text-slate-500 mb-1">SOUL TYPE</div>
                        <div class="text-sm font-bold text-slate-200 mb-2">${this.elements.my.n}</div>
                        <p class="text-[10px] text-slate-400 leading-relaxed border-t border-slate-700/50 pt-2">
                            あなたの本質的なエネルギータイプです。${this.elements.my.desc}を司ります。
                        </p>
                    </div>
                    <div class="glass-panel p-4 rounded-xl border-l-2 border-l-yellow-500 bg-yellow-500/5">
                        <div class="text-[10px] font-mono text-yellow-600 mb-1">GUARDIAN (TARGET)</div>
                        <div class="text-sm font-bold text-yellow-400 mb-2">${this.elements.guard.n}</div>
                        <p class="text-[10px] text-yellow-100/70 leading-relaxed border-t border-yellow-500/20 pt-2 text-justify">
                            ${this.elements.guard.detail}
                        </p>
                    </div>
                    <div class="glass-panel p-4 rounded-xl border-l-2 border-l-teal-500">
                        <div class="text-[10px] font-mono text-teal-600 mb-1">BASE FREQUENCY</div>
                        <div class="text-sm font-bold text-teal-400 mb-2 font-mono">${this.elements.guard.freq} Hz</div>
                        <p class="text-[10px] text-slate-400 leading-relaxed border-t border-slate-700/50 pt-2">
                            不足エネルギーを補うための物理的な搬送波周波数です。この音がアンカーとなります。
                        </p>
                    </div>
                `;
                document.getElementById('sanmei-result').innerHTML = html;
                
                // step2はanalyzeSequenceで既に表示されている
                this.initAudio();
                setTimeout(() => this.drawGridOnly(), 100);
            },

            initAudio: function() {
                if(!this.ctx) {
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                            latencyHint: 'interactive',
                            sampleRate: 44100
                        });
                        this.analyzer = this.ctx.createAnalyser();
                        this.analyzer.fftSize = 2048;
                        console.log('✅ AudioContext initialized:', this.ctx.state);
                    } catch(e) {
                        console.error('❌ AudioContext init error:', e);
                        alert('音声システムの初期化に失敗しました。ブラウザを更新してください。');
                        return;
                    }
                }
                // モバイル対応: suspended状態を確実にresumeする
                if(this.ctx.state === 'suspended') {
                    this.ctx.resume().then(() => {
                        console.log('✅ AudioContext resumed');
                    }).catch(e => {
                        console.error('❌ Resume error:', e);
                    });
                }
            },

            playSound: function() {
                if(this.isPlaying) return;
                this.initAudio();
                
                // モバイル対応: 再生前に確実にresumeする
                if(this.ctx.state === 'suspended') {
                    this.ctx.resume().then(() => {
                        console.log('✅ AudioContext resumed for playback');
                        this.executePlaySound();
                    }).catch(e => {
                        console.error('❌ Resume failed:', e);
                        alert('音声の再生に失敗しました。\nページを更新して再度お試しください。');
                    });
                } else {
                    this.executePlaySound();
                }
            },

            executePlaySound: function() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(this.elements.guard.freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.5);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
                osc.connect(gain);
                gain.connect(this.analyzer);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 4);
                this.isPlaying = true;
                const btn = document.getElementById('btn-play');
                btn.innerHTML = "GENERATING WAVES...";
                btn.classList.add('opacity-50', 'cursor-not-allowed');
                this.visualize();
                setTimeout(() => {
                    this.isPlaying = false;
                    btn.innerHTML = "▶ REPLAY AUDIO";
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    this.showStep('step3');
                }, 4000);
            },

            startMic: function() {
                this.initAudio();
                this.audioSamples = []; // サンプルをリセット
                this.recordingStartTime = Date.now();
                
                navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                }).then(stream => {
                    console.log('✅ Microphone access granted');
                    this.micSrc = this.ctx.createMediaStreamSource(stream);
                    this.micSrc.connect(this.analyzer);
                    this.micStream = stream; // ストリームを保存
                    
                    // フローティングウィンドウを表示
                    const floatDiv = document.getElementById('recording-float');
                    floatDiv.classList.add('active');
                    
                    // 録音ボタンを無効化
                    const btnRec = document.getElementById('btn-rec');
                    btnRec.disabled = true;
                    btnRec.classList.add('opacity-50');
                    
                    // 5秒タイマーを開始
                    this.startRecordingTimer();
                    
                    // 波形の可視化開始
                    this.visualizeFloating();
                    
                    // 音声データ収集開始
                    this.collectAudioData();
                    
                }).catch(e => {
                    console.error("❌ Microphone access error:", e);
                    
                    let errorMsg = 'マイクへのアクセスに失敗しました。\n\n';
                    
                    if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                        errorMsg += 'マイクの使用が許可されていません。\n';
                        if (isIOS) {
                            errorMsg += '\niPhoneの場合:\n設定 > Safari > カメラとマイク\nからマイクを許可してください。';
                        } else if (isMobile) {
                            errorMsg += '\nブラウザの設定でマイクの使用を許可してください。';
                        } else {
                            errorMsg += '\nブラウザのアドレスバー付近のアイコンから\nマイクの使用を許可してください。';
                        }
                    } else if (e.name === 'NotFoundError') {
                        errorMsg += 'マイクが見つかりませんでした。\nマイクが接続されているか確認してください。';
                    } else {
                        errorMsg += 'エラー: ' + e.message;
                    }
                    
                    alert(errorMsg);
                });
            },

            startRecordingTimer: function() {
                const timerEl = document.getElementById('rec-timer');
                const duration = 5.0; // 5秒
                const startTime = Date.now();
                
                const updateTimer = () => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const remaining = Math.max(0, duration - elapsed);
                    timerEl.textContent = remaining.toFixed(1);
                    
                    if (remaining > 0) {
                        requestAnimationFrame(updateTimer);
                    } else {
                        // 5秒経過したら自動停止
                        this.stopMicAuto();
                    }
                };
                updateTimer();
            },

            visualizeFloating: function() {
                const canvas = document.getElementById('floatingWaveform');
                if (!canvas) return;
                
                const c = canvas.getContext('2d');
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
                
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    if (!this.micSrc) return; // 録音停止時は終了
                    
                    this.floatingAnimId = requestAnimationFrame(draw);
                    this.analyzer.getByteTimeDomainData(dataArray);
                    
                    // 背景をクリア
                    c.fillStyle = '#000';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // 中央線を描画
                    c.lineWidth = 1;
                    c.strokeStyle = 'rgba(30,41,59,0.5)';
                    c.beginPath();
                    c.moveTo(0, canvas.height / 2);
                    c.lineTo(canvas.width, canvas.height / 2);
                    c.stroke();
                    
                    // 波形を描画
                    c.lineWidth = 2;
                    c.strokeStyle = '#ec4899'; // フューシャ色
                    c.shadowBlur = 10;
                    c.shadowColor = '#ec4899';
                    c.beginPath();
                    
                    const sliceWidth = canvas.width / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * canvas.height / 2;
                        
                        if (i === 0) {
                            c.moveTo(x, y);
                        } else {
                            c.lineTo(x, y);
                        }
                        x += sliceWidth;
                    }
                    
                    c.lineTo(canvas.width, canvas.height / 2);
                    c.stroke();
                };
                draw();
            },

            stopMicAuto: function() {
                // マイクを停止
                if (this.micSrc) {
                    this.micSrc.disconnect();
                    this.micSrc = null;
                }
                
                // ストリームを停止
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => track.stop());
                    this.micStream = null;
                }
                
                // アニメーションを停止
                if (this.floatingAnimId) {
                    cancelAnimationFrame(this.floatingAnimId);
                }
                
                // フローティングウィンドウを閉じる
                const floatDiv = document.getElementById('recording-float');
                floatDiv.classList.remove('active');
                
                // stopMic関数の処理を実行
                this.stopMic();
            },

            collectAudioData: function() {
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const collect = () => {
                    if (!this.micSrc) return; // 録音停止時は終了
                    
                    this.analyzer.getByteFrequencyData(dataArray);
                    // 周波数データをコピーして保存
                    this.audioSamples.push(new Uint8Array(dataArray));
                    
                    // 録音時間を表示
                    const elapsed = ((Date.now() - this.recordingStartTime) / 1000).toFixed(1);
                    const statusEl = document.getElementById('rec-status');
                    if (statusEl) {
                        statusEl.textContent = `Recording: ${elapsed}s | Samples: ${this.audioSamples.length}`;
                    }
                    
                    // 100ms間隔でサンプリング（5秒で約50サンプル）
                    setTimeout(() => collect(), 100);
                };
                collect();
            },

            stopMic: function() {
                // 既に停止処理が実行中の場合はスキップ
                if (this.isProcessing) return;
                this.isProcessing = true;
                
                // 録音ボタンをリセット
                const btnRec = document.getElementById('btn-rec');
                btnRec.disabled = false;
                btnRec.classList.remove('opacity-50');
                btnRec.innerHTML = "● START RECORDING";
                
                const btnStop = document.getElementById('btn-stop');
                btnStop.disabled = true;
                btnStop.classList.remove('bg-slate-100', 'text-slate-900');
                btnStop.classList.add('bg-slate-800', 'text-teal-400', 'animate-pulse');
                
                // 録音状況表示を更新
                const statusEl = document.getElementById('rec-status');
                if (statusEl) {
                    statusEl.textContent = `Processing ${this.audioSamples.length} samples...`;
                    statusEl.className = 'mt-4 text-xs text-yellow-400 font-mono text-center h-4 animate-pulse';
                }
                
                const msgs = ["INTEGRATING BIO-RHYTHM...", "FFT ANALYSIS: PROCESSING...", "ALIGNING DIMENSIONS...", "FINALIZING RESONANCE..."];
                let i = 0;
                const timer = setInterval(() => { btnStop.innerText = "■ " + msgs[i++ % msgs.length]; }, 700);

                setTimeout(() => {
                    clearInterval(timer);
                    if(this.micSrc) this.micSrc.disconnect();
                    cancelAnimationFrame(this.animId);
                    
                    // ★ 実際のFFT分析を実行
                    const analysis = this.analyzeRecordedAudio();
                    this.recordedData = analysis.fiveElements;
                    const detectedHz = analysis.dominantFreq;
                    const syncRate = analysis.syncRate;

                    document.getElementById('voice-comment').innerHTML = `
                        <div class="flex justify-center gap-8 font-mono text-xs mb-2">
                            <span>VOICE: <b class="text-teal-400">${detectedHz} Hz</b></span>
                            <span>TARGET: <b class="text-yellow-400">${this.elements.guard.freq} Hz</b></span>
                        </div>
                        <div class="text-xl font-bold text-teal-300">SYNC RATE: ${syncRate}%</div>
                    `;
                    
                    // 音声データを生成・保存・描画
                    this.generateResonanceBuffer();
                    // 期間表示を更新
                    const durationEl = document.getElementById('duration-display');
                    if (durationEl) {
                        durationEl.textContent = `(${this.audioDuration}s)`;
                    }
                    this.showStep('step4');
                    this.draw3LayerRadar();
                    this.drawFinalWaveform(); // ★最終波形を描画
                    
                    this.isProcessing = false;

                }, 3000);
            },

            // ★ 新規追加: 実際のFFT分析関数
            analyzeRecordedAudio: function() {
                if (this.audioSamples.length === 0) {
                    console.warn("No audio samples recorded");
                    return {
                        fiveElements: [50, 50, 50, 50, 50],
                        dominantFreq: 200,
                        syncRate: 50.0
                    };
                }

                // サンプリングレート44100Hzの場合、analyzerのfftSizeが2048なら
                // 各binは約21.5Hz (44100 / 2048)
                const sampleRate = this.ctx.sampleRate;
                const fftSize = this.analyzer.fftSize;
                const binWidth = sampleRate / fftSize;

                // 周波数帯域の定義（五行に対応）
                // 木(100-300Hz), 火(300-600Hz), 土(600-1000Hz), 金(1000-2000Hz), 水(2000-4000Hz)
                const bands = [
                    { name: '木', min: 100, max: 300 },
                    { name: '火', min: 300, max: 600 },
                    { name: '土', min: 600, max: 1000 },
                    { name: '金', min: 1000, max: 2000 },
                    { name: '水', min: 2000, max: 4000 }
                ];

                // 全サンプルの平均スペクトルを計算
                const avgSpectrum = new Float32Array(this.audioSamples[0].length);
                for (let sample of this.audioSamples) {
                    for (let i = 0; i < sample.length; i++) {
                        avgSpectrum[i] += sample[i];
                    }
                }
                for (let i = 0; i < avgSpectrum.length; i++) {
                    avgSpectrum[i] /= this.audioSamples.length;
                }

                // 各帯域のエネルギーを計算
                const bandEnergies = bands.map(band => {
                    const startBin = Math.floor(band.min / binWidth);
                    const endBin = Math.floor(band.max / binWidth);
                    let energy = 0;
                    for (let i = startBin; i <= endBin && i < avgSpectrum.length; i++) {
                        energy += avgSpectrum[i];
                    }
                    return energy / (endBin - startBin + 1);
                });

                // 0-100のスケールに正規化
                const maxEnergy = Math.max(...bandEnergies, 1);
                const fiveElements = bandEnergies.map(e => Math.min(100, (e / maxEnergy) * 100));

                // 優勢な周波数を検出
                let maxVal = 0;
                let maxIdx = 0;
                for (let i = 0; i < avgSpectrum.length; i++) {
                    if (avgSpectrum[i] > maxVal) {
                        maxVal = avgSpectrum[i];
                        maxIdx = i;
                    }
                }
                const dominantFreq = Math.round(maxIdx * binWidth);

                // 守護周波数との同期率を計算
                const targetFreq = this.elements.guard.freq;
                const freqDiff = Math.abs(dominantFreq - targetFreq);
                const syncRate = Math.max(0, Math.min(100, 100 - (freqDiff / targetFreq * 100))).toFixed(1);

                console.log("✅ FFT Analysis Results:", {
                    fiveElements,
                    dominantFreq,
                    syncRate,
                    sampleCount: this.audioSamples.length,
                    bands: bands.map((b, i) => `${b.name}: ${fiveElements[i].toFixed(1)}`)
                });

                return { fiveElements, dominantFreq, syncRate };
            },

            // ★追加: 最終的な音声データを生成する関数
            generateResonanceBuffer: function(customDuration) {
                const sampleRate = 44100;
                const duration = customDuration || parseInt(document.getElementById('inp-duration').value) || 10;
                const samples = sampleRate * duration;
                const buffer = new Float32Array(samples);
                const guardFreq = this.elements.guard.freq; // 守護周波数
                const schumannFreq = 7.83; // シューマン共鳴周波数

                // フェード時間を長さに応じて調整（最大2秒）
                const fadeTime = Math.min(2, duration * 0.2);

                for (let i = 0; i < samples; i++) {
                    const t = i / sampleRate;
                    let envelope = 1;
                    if (t < fadeTime) envelope = t / fadeTime; // フェードイン
                    if (t > duration - fadeTime) envelope = (duration - t) / fadeTime; // フェードアウト
                    
                    // 守護周波数のサイン波
                    const guardWave = Math.sin(2 * Math.PI * guardFreq * t) * 0.4;
                    
                    // 7.83Hz シューマン共鳴周波数
                    const schumannWave = Math.sin(2 * Math.PI * schumannFreq * t) * 0.15;
                    
                    // 2つの周波数を合成
                    buffer[i] = (guardWave + schumannWave) * envelope;
                }
                this.finalAudioBuffer = buffer; // メモリに保存
                this.audioDuration = duration; // 長さを保存
                
                console.log(`✨ Generated audio: ${guardFreq}Hz (Guardian) + ${schumannFreq}Hz (Schumann)`);
            },

            // ★追加: 最終波形を描画する関数
            drawFinalWaveform: function() {
                const canvas = document.getElementById('finalWaveVisualizer');
                const c = canvas.getContext('2d');
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
                
                const buffer = this.finalAudioBuffer;
                if(!buffer) return;

                c.fillStyle = '#020617'; // 背景
                c.fillRect(0, 0, canvas.width, canvas.height);

                c.lineWidth = 1;
                c.strokeStyle = '#2dd4bf'; // Teal-400
                c.beginPath();

                const step = Math.ceil(buffer.length / canvas.width);
                const ampHeight = canvas.height / 2;

                for(let i = 0; i < canvas.width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = buffer[i * step + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    // 波形ブロックを描画
                    c.moveTo(i, (1 + min) * ampHeight);
                    c.lineTo(i, (1 + max) * ampHeight);
                }
                c.stroke();
            },

            drawGridOnly: function() {
                const canvas = document.getElementById('visualizer');
                const c = canvas.getContext('2d');
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
                c.fillStyle = '#000';
                c.fillRect(0, 0, canvas.width, canvas.height);
                c.lineWidth=1; c.strokeStyle='rgba(30,41,59,0.5)'; c.beginPath(); c.moveTo(0,canvas.height/2); c.lineTo(canvas.width,canvas.height/2); c.stroke();
            },

            visualize: function() {
                const canvas = document.getElementById('visualizer');
                const c = canvas.getContext('2d');
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const freqArray = new Uint8Array(bufferLength); // 周波数データ用
                let lastSampleTime = Date.now();
                const statusEl = document.getElementById('rec-status');
                
                const draw = () => {
                    this.animId = requestAnimationFrame(draw);
                    this.analyzer.getByteTimeDomainData(dataArray);
                    
                    // 周波数データを100msごとにサンプリング
                    const now = Date.now();
                    if (now - lastSampleTime > 100) {
                        this.analyzer.getByteFrequencyData(freqArray);
                        this.frequencyData.push(new Uint8Array(freqArray)); // コピーして保存
                        lastSampleTime = now;
                        
                        // 録音状況を表示
                        if (statusEl) {
                            const duration = ((now - this.recordingStartTime) / 1000).toFixed(1);
                            statusEl.textContent = `Recording: ${duration}s | Samples: ${this.frequencyData.length}`;
                            statusEl.className = 'mt-4 text-xs text-teal-400 font-mono text-center h-4';
                        }
                    }
                    
                    c.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    c.fillRect(0, 0, canvas.width, canvas.height);
                    c.lineWidth=1; c.strokeStyle='rgba(30,41,59,0.5)'; c.beginPath(); c.moveTo(0,canvas.height/2); c.lineTo(canvas.width,canvas.height/2); c.stroke();

                    c.lineWidth = 2; c.strokeStyle = '#14b8a6'; c.shadowBlur = 8; c.shadowColor = '#14b8a6';
                    c.beginPath();
                    const sliceWidth = canvas.width / bufferLength; let x = 0; let maxAmp = 0;
                    for(let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0; const y = v * canvas.height / 2;
                        const amp = Math.abs(dataArray[i] - 128); if(amp > maxAmp) maxAmp = amp;
                        if(i===0) c.moveTo(x, y); else c.lineTo(x, y); x += sliceWidth;
                    }
                    c.lineTo(canvas.width, canvas.height/2); c.stroke();
                    if(maxAmp>0) { const db=(20*Math.log10(maxAmp/128)).toFixed(1); document.getElementById('gain-val').innerText=db>-100?db+" dB":"-INF"; }
                };
                draw();
            },

            draw3LayerRadar: function() {
                const ctx = document.getElementById('radarChart').getContext('2d');
                Chart.defaults.color = '#64748b'; Chart.defaults.borderColor = 'rgba(148, 163, 184, 0.1)';
                if(this.chart) this.chart.destroy();
                this.chart = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: ['木 (WOOD)', '火 (FIRE)', '土 (EARTH)', '金 (METAL)', '水 (WATER)'],
                        datasets: [
                            { label: '算命学 (IDEAL)', data: [80, 80, 100, 80, 80], borderColor: '#eab308', backgroundColor: 'rgba(234, 179, 8, 0.1)', borderWidth: 2, pointRadius: 0 },
                            { label: 'カタカムナ (NAME)', data: this.nameData, borderColor: '#14b8a6', backgroundColor: 'rgba(20, 184, 166, 0.0)', borderWidth: 2, borderDash: [5, 5], pointRadius: 3 },
                            { label: '生体音声 (VOICE)', data: this.recordedData, borderColor: '#d946ef', backgroundColor: 'rgba(217, 70, 239, 0.2)', borderWidth: 2, pointBackgroundColor: '#d946ef' }
                        ]
                    },
                    options: {
                        scales: { r: { angleLines: { color: 'rgba(255,255,255,0.05)' }, grid: { color: 'rgba(255,255,255,0.05)' }, pointLabels: { font: { size: 11 }, color: '#94a3b8' }, min: 0, max: 100, ticks: { display: false } } },
                        plugins: { legend: { labels: { color: '#cbd5e1', font: { size: 10 } }, position: 'bottom' } }, maintainAspectRatio: false
                    }
                });
            },

            downloadWav: function() {
                if(!this.finalAudioBuffer) this.generateResonanceBuffer();
                const buffer = this.finalAudioBuffer;
                const duration = this.audioDuration || 10;
                const wavBytes = this.encodeWAV(buffer, 44100);
                const blob = new Blob([wavBytes], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); 
                a.href = url; 
                a.download = `AstroResonance_${this.elements.guard.freq}Hz+7.83Hz_${duration}sec.wav`; 
                a.click();
            },

            encodeWAV: function(samples, sampleRate) {
                const buffer = new ArrayBuffer(44 + samples.length * 2);
                const view = new DataView(buffer);
                const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
                writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
                writeString(view, 8, 'WAVE'); writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true); view.setUint16(34, 16, true);
                writeString(view, 36, 'data'); view.setUint32(40, samples.length * 2, true);
                let offset = 44;
                for (let i = 0; i < samples.length; i++) {
                    const s = Math.max(-1, Math.min(1, samples[i]));
                    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true); offset += 2;
                }
                return view;
            },

            // ★ アラーム音生成関数
            generateAlarms: function() {
                console.log('🔔 Generating alarm sounds...');
                
                // 確認部分を非表示
                document.getElementById('alarm-confirm').classList.add('hidden');
                
                // 生成中表示
                document.getElementById('alarm-generating').classList.remove('hidden');
                
                setTimeout(() => {
                    // パターン1とパターン2を生成
                    this.alarmPattern1 = this.generateAlarmPattern1();
                    this.alarmPattern2 = this.generateAlarmPattern2();
                    
                    // 完成表示
                    document.getElementById('alarm-generating').classList.add('hidden');
                    document.getElementById('alarm-ready').classList.remove('hidden');
                    
                    console.log('✅ Alarm sounds generated');
                }, 2000);
            },

            generateAlarmPattern1: function() {
                // パターン1: 静かな呼吸に同調する目覚め
                // 15〜25秒フェードイン、揺らぎあり
                const sampleRate = 44100;
                const duration = 30; // 30秒
                const samples = sampleRate * duration;
                const buffer = new Float32Array(samples);
                
                const guardFreq = this.elements.guard.freq;
                const schumannFreq = 7.83;
                const fadeInTime = 20; // 20秒でフェードイン
                
                for (let i = 0; i < samples; i++) {
                    const t = i / sampleRate;
                    
                    // 非常に緩やかなフェードイン（指数関数的）
                    let envelope = 0;
                    if (t < fadeInTime) {
                        envelope = Math.pow(t / fadeInTime, 2.5) * 0.001; // 非常に小さく開始
                        envelope = Math.min(envelope, 0.3); // 最大音量を抑える
                    } else {
                        envelope = 0.3;
                    }
                    
                    // 揺らぎを追加（LFO - Low Frequency Oscillator）
                    const vibrato = Math.sin(2 * Math.PI * 0.05 * t) * 0.002; // 音程の揺らぎ
                    const tremolo = Math.sin(2 * Math.PI * 0.08 * t) * 0.1 + 1; // 音量の揺らぎ
                    
                    // 基音（守護周波数）- 丸みのある倍音構成
                    const fundamental = Math.sin(2 * Math.PI * (guardFreq + vibrato * guardFreq) * t);
                    const harmonic2 = Math.sin(2 * Math.PI * (guardFreq * 2) * t) * 0.3; // 2倍音
                    const harmonic3 = Math.sin(2 * Math.PI * (guardFreq * 3) * t) * 0.15; // 3倍音（控えめ）
                    
                    // シューマン共鳴
                    const schumann = Math.sin(2 * Math.PI * schumannFreq * t) * 0.2;
                    
                    // 合成
                    buffer[i] = (fundamental * 0.5 + harmonic2 + harmonic3 + schumann) * envelope * tremolo;
                }
                
                console.log('🔔 Pattern 1 generated: Gentle Breathing');
                return buffer;
            },

            generateAlarmPattern2: function() {
                // パターン2: 朝の光がカーテン越しに差し込む瞬間
                // 20秒以上フェードイン、中高域倍音追加
                const sampleRate = 44100;
                const duration = 30; // 30秒
                const samples = sampleRate * duration;
                const buffer = new Float32Array(samples);
                
                const guardFreq = this.elements.guard.freq;
                const schumannFreq = 7.83;
                const fadeInTime = 25; // 25秒でフェードイン
                
                for (let i = 0; i < samples; i++) {
                    const t = i / sampleRate;
                    
                    // 非常に緩やかなフェードイン
                    let envelope = 0;
                    if (t < fadeInTime) {
                        envelope = Math.pow(t / fadeInTime, 3) * 0.0005; // さらに小さく開始
                        envelope = Math.min(envelope, 0.35);
                    } else {
                        envelope = 0.35;
                    }
                    
                    // 明るさの進行（中高域倍音の増加）
                    const brightness = Math.min(t / fadeInTime, 1);
                    
                    // 基音
                    const fundamental = Math.sin(2 * Math.PI * guardFreq * t);
                    
                    // 倍音構成（明るさに応じて増加）
                    const harmonic2 = Math.sin(2 * Math.PI * (guardFreq * 2) * t) * 0.25 * brightness;
                    const harmonic3 = Math.sin(2 * Math.PI * (guardFreq * 3) * t) * 0.15 * brightness;
                    const harmonic4 = Math.sin(2 * Math.PI * (guardFreq * 4) * t) * 0.1 * brightness; // 中高域
                    const harmonic5 = Math.sin(2 * Math.PI * (guardFreq * 5) * t) * 0.05 * brightness; // 高域（控えめ）
                    
                    // シューマン共鳴
                    const schumann = Math.sin(2 * Math.PI * schumannFreq * t) * 0.15;
                    
                    // 空間的な広がり（わずかなコーラス効果）
                    const chorus = Math.sin(2 * Math.PI * (guardFreq * 1.002) * t) * 0.1 * brightness;
                    
                    // 合成
                    buffer[i] = (fundamental * 0.45 + harmonic2 + harmonic3 + harmonic4 + harmonic5 + schumann + chorus) * envelope;
                }
                
                console.log('🌅 Pattern 2 generated: Morning Light');
                return buffer;
            },

            downloadAlarm: function(pattern) {
                let buffer, filename;
                
                if (pattern === 1) {
                    if (!this.alarmPattern1) this.alarmPattern1 = this.generateAlarmPattern1();
                    buffer = this.alarmPattern1;
                    filename = `Alarm_GentleBreathing_${this.elements.guard.freq}Hz.wav`;
                } else {
                    if (!this.alarmPattern2) this.alarmPattern2 = this.generateAlarmPattern2();
                    buffer = this.alarmPattern2;
                    filename = `Alarm_MorningLight_${this.elements.guard.freq}Hz.wav`;
                }
                
                const wavBytes = this.encodeWAV(buffer, 44100);
                const blob = new Blob([wavBytes], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                
                console.log(`✅ Downloaded: ${filename}`);
            },

            showStep: function(id) {
                const el = document.getElementById(id);
                if (!el) {
                    console.error('Element not found:', id);
                    return;
                }
                el.classList.remove('hidden');
                el.classList.add('anim-entry');
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };

        window.onload = () => {
            console.log('🟢 Page loaded, initializing app...');
            app.init();
        };
    </script>
</body>
</html>
